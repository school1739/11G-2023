class MathNeuron:
    def __init__(self, num_inputs):
        self.weights = []
        for i in range(num_inputs):
            self.weights.append(1)  # инициализация веса до 1
        self.bias = 0

    def calculate_output(self, inputs):
        sum = 0
        for i in range(len(inputs)):
            sum += inputs[i] * self.weights[i]
        sum += self.bias
        output = 1 / (1 + pow(2.71828, -sum))
        return output

    def set_weights(self, weights):
        self.weights = weights

    def set_bias(self, bias):
        self.bias = bias

    def get_weights(self):
        return self.weights

    def get_bias(self):
        return self.bias


class SElement(MathNeuron):
    def __init__(self, num_inputs, threshold):
        super().__init__(num_inputs)
        self.threshold = threshold

    def calculate_output(self, inputs):
        sum = 0
        for i in range(len(inputs)):
            sum += inputs[i] * self.weights[i]
        sum += self.bias
        if sum >= self.threshold:
            output = 1
        else:
            output = 0
        return output


class AElement(MathNeuron):
    def __init__(self, num_inputs, threshold):
        super().__init__(num_inputs)
        self.threshold = threshold

    def calculate_output(self, inputs):
        sum = 0
        for i in range(len(inputs)):
            sum += inputs[i] * self.weights[i]
        sum += self.bias
        if sum >= self.threshold:
            output = 1
        else:
            output = 0
        return output


class RElement(MathNeuron):
    def __init__(self, num_inputs):
        super().__init__(num_inputs)

    def calculate_output(self, inputs):
        sum = 0
        for i in range(len(inputs)):
            sum += inputs[i] * self.weights[i]
        sum += self.bias
        if sum > 0:
            output = 1
        elif sum < 0:
            output = -1
        else:
            output = 0
        return output
import random


class NeuralLayer:
    def __init__(self, neuron_type, num_neurons, x=None):
        self.neurons = []
        for i in range(num_neurons):
            if x is not None:
                neuron = neuron_type(x)
# КЛАСС ДЛЯ МАТЕМАТИЧЕСКОГО НЕЙРОНА (СЧИТАЕМ, ЧТО ЧИСЛО ВЫХОДОВ МОЖЕТ БЫТЬ > 1Б ДЕНДРИТЫ НЕ УЧИТЫВАЕМ)
class MathNeuron:
    def __init__(self, x_count, w, theta):
        self.x_count = x_count
        self.w = w + random.random(-0.25, 0.25)
        self.theta = theta
        self.sum = 0
        print(f"Создан нейрон с количеством входов {self.x_count}, весом {self.w} и порогом {self.theta}")

    def get_info(self):
        print(f"Нейрон с количеством входов {self.x_count}, весом {self.w} и порогом {self.theta}")

    def activate(self, x):
        if len(x) != self.x_count:
            print("Количество входов не соответствует количеству входов нейрона")
        else:
            self.sum = 0
            for i in range(self.x_count):
                self.sum += x[i] * self.w[i]
            if self.sum > self.theta:
                print("Нейрон активирован")
                return True
            else:
                neuron = neuron_type()
            self.neurons.append(neuron)

    def compute_outputs(self, inputs):
        outputs = []
        for neuron in self.neurons:
            outputs.append(neuron.calculate_output(inputs))
        return outputs

    def set_weights(self, weights):
        for neuron, weight in zip(self.neurons, weights):
            neuron.set_weights(weight)

    def set_bias(self, biases):
        for neuron, bias in zip(self.neurons, biases):
            neuron.set_bias(bias)

    def get_neurons(self):
        return self.neurons

                print("Нейрон не активирован")
                return False

#  ТРИ ПОДКЛАССА
class SNeuron(MathNeuron):
    def __init__(self):
        super().__init__(1, 1, 1)
        print("Создан нейрон S")

    def activate(self, x):
        if x > self.theta:
            print("Нейрон S активирован")
            return True
        else:
            print("Нейрон S не активирован")
            return False

def create_disconnected_nn(layer_num, first_layer_neurons):
    network = []
    current_layer_neurons = first_layer_neurons

    for i in range(layer_num):
        layer = []
class ANeuron(MathNeuron):
    def __init__(self, x_count, w, theta):
        super().__init__(x_count, w, theta)
        print("Создан нейрон A")

        for j in range(current_layer_neurons):
            if j == 0:
                layer.append('S')
            elif j % 2 == 0:
                layer.append('A')
    def activate(self, x):
        if self.x_count == 0:
            print("Нет входов")
            return None
        else:
            if super().activate(x):
                return True
            else:
                layer.append('R')
                return False

        network.append(layer)
        current_layer_neurons = (current_layer_neurons // 2) + (current_layer_neurons % 2)

    network.append(['S'])

    return network
class RNeuron(MathNeuron):
    def __init__(self, x_count, w, theta):
        super().__init__(x_count, w, theta)
        print("Создан нейрон R")

    def activate(self):
        if self.sum > self.theta:
            print("Нейрон R активирован")
            return 1
        elif self.sum == self.theta:
            print("Нейрон R не определён")
            return None
        else:
            print("Нейрон R не активирован")
            return -1

#   УНИВЕРСАЛЬНЫЙ КЛАСС ДЛЯ НЕЙРОННОГО СЛОЯ
class Layer:
    def __init__(self, type, number, x):
        self.type = type
        self.number = number
        self.x = x
        self.neurons = []
        self.create_neurons()

    def create_neurons(self):
        if self.type == "S":
            for i in range(self.number):
                self.neurons.append(SNeuron())
        elif self.type == "A":
            for i in range(self.number):
                self.neurons.append(ANeuron(self.x, 1, 1))
        elif self.type == "R":
            for i in range(self.number):
                self.neurons.append(RNeuron(self.x, 1, 1))
        else:
            print("Неверный тип нейрона")
            return None


# ФУНКЦИЯ СОЗДАНИЯ НЕСВЯЗНОЙ НЕЙРОННОЙ СЕТИ:
# Функция создаёт нужное количество слоёв нейронов по правилу: количество нейронов в первом слоё задаётся явно,
# второй слой -- вдвое больше первого, каждый последующий -- вдвое меньше предыдущего (количество нейронов
# округляем до чётных вверх); слои создаются в нужном количестве, пока в слое не останется один нейрон;
# типы (S, A, R) в слоях определяются автоматически.
# Args:
# Layers number
# 1st layer neurons number
def create_layers(number):
    layers = []
    for i in range(number):
        layers.append(Layer(random.choice(["S", "A", "R"]), random.choice([1, 2, 3]), random.choice([1, 2, 3])))
    return layers
